/**
 * Codasip s.r.o.
 *
 * CONFIDENTIAL
 *
 * Copyright 2022 Codasip s.r.o.
 *
 * All Rights Reserved.
 *
 * NOTICE: All information contained in this file, is and shall remain the property of
 * Codasip s.r.o. and its suppliers, if any.
 *
 * The intellectual and technical concepts contained herein are confidential and proprietary to
 * Codasip s.r.o. and are protected by trade secret and copyright law.  In addition, elements of the
 * technical concepts may be patent pending.
 *
 * This file is part of the Codasip Studio product. No part of the Studio product, including this
 * file, may be use, copied, modified, or distributed except in accordance with the terms contained
 * in Codasip license agreement under which you obtained this file.
 *
 *  \file   ca_
 *  """""""""""""""""""""""""""""resources.codal
 *  \author Codasip
 *  \date   09.02.2022
 *  \brief  cycle accurate model
 */

#include "ca_defines.hcodal"
#include "config.hcodal"

#define BOOLEAN_BIT     1    // Boolean control bit of width 1-bit
#define TWO_BIT         2       // Two bit wide control signal

pipeline pipe
{
    IFID, IDEX, EXMEM, MEMWB
};

// -------------------------------------------------------------------------------------------------
// Fetch stage
// -------------------------------------------------------------------------------------------------

// Current Program Counter (PC) address of instruction fetch request
signal bit[ADDR_W] s_if_nextpc;

// IFID pipeline register
register bit[ADDR_W]        r_ifid_pc             { pipeline = pipe.IFID; };     // Program Counter

// -------------------------------------------------------------------------------------------------
// Decode stage
// -------------------------------------------------------------------------------------------------


// Instruction and parsed instruction fields
signal bit[INSTR_W]         s_id_instr;                 // Instruction
signal bit[OPC_W]           s_id_opcode;                // Complete 17-bit opcode
signal bit[RF_XPR_W]        s_id_src1;                  // src1 register address
signal bit[RF_XPR_W]        s_id_src2;                  // src2 register address
signal bit[RF_XPR_W]        s_id_rd;                    // rd destination address
signal bit[WORD_W]          s_id_rf_src1;               // value of src1 from register file
signal bit[WORD_W]          s_id_rf_src2;               // value of src2 from regsiter file

// ALU Operation Control
signal bit[ALUOP_W]         s_id_aluop;                 // ALU opcode
signal bit[BOOLEAN_BIT]        s_id_halt;                  // Control bit to halt processor simulation


// Immediate operand generation resources
signal bit[IMM_GEN_SEL_W]   s_id_imm_gen_sel;           // select the type of immediate to pass to execute stage
signal bit[WORD_W]          s_id_imm_rtype;
signal bit[WORD_W]          s_id_imm_itype;
signal bit[WORD_W]          s_id_imm_stype;
signal bit[WORD_W]          s_id_imm_btype;
signal bit[WORD_W]          s_id_imm_utype;
signal bit[WORD_W]          s_id_imm_jtype;


// Singals/registers to preserve instruction durin a pipeline stall
signal bit[BOOLEAN_BIT]     s_id_icache_stall;
register bit[BOOLEAN_BIT]   r_id_icache_stall            {default = false;};   // 1-cycle delay of s_id_icache_stall for timing
register bit[BOOLEAN_BIT]   r_id_flush_icache            {default = false;};   // used to flush current instruction being read
register bit[BOOLEAN_BIT]   r_id_buffer_full             {default = false;};   // indicate whether previous cycle stalled
register bit[INSTR_W]       r_id_instr_preserved;       // Preserve last instruction to reconstruct inst. in stall
register bit[WORD_W]        r_id_pc_preserved;          // Preserve the PC address of instruction safed in buffer



// Signals generated by the Instruction Decoder
signal bit[BOOLEAN_BIT]        s_id_regwrite;           // Write to rd (write register) if true
signal bit[ALU_SRC1_SEL_W]  s_id_alusrc1;               // src1 operand mux select line
signal bit[ALU_SRC2_SEL_W]  s_id_alusrc2;               // src2 operand mux select line
signal bit[MEM_OPCODE_W]    s_id_mem_ops;               // Memory opcode
signal bit[BOOLEAN_BIT]        s_id_memread;            // Memory load operation if true
signal bit[BOOLEAN_BIT]        s_id_branch_inst;        // bit used to notify an instruction is a branch
signal bit[BOOLEAN_BIT]        s_id_jump_inst;          // bit used to notify a jump instruction

// Associated signals for data hazard detection and forwarding
signal bit[BOOLEAN_BIT]        s_id_src1_ex_hz;            // Hazard detected if true
signal bit[BOOLEAN_BIT]        s_id_src2_ex_hz;            // Hazard detected if true
signal bit[BOOLEAN_BIT]        s_id_src1_mem_hz;           // Hazard detected if true
signal bit[BOOLEAN_BIT]        s_id_src2_mem_hz;           // Hazard detected if true
signal bit[BOOLEAN_BIT]        s_id_src1_wb_hz;            // Hazard detected if true
signal bit[BOOLEAN_BIT]        s_id_src2_wb_hz;            // Hazard detected if true


// IDEX pipeline register
register bit[ADDR_W]        r_idex_pc           { pipeline = pipe.IDEX; };    // Program Counter
register bit[RF_XPR_W]      r_idex_rd           { pipeline = pipe.IDEX; };    // rd (write) register number
register bit[WORD_W]        r_idex_src1         { pipeline = pipe.IDEX; };    // register file output for src1, rs1
register bit[WORD_W]        r_idex_src2         { pipeline = pipe.IDEX; };    // register file output for src2, rs2
register bit[WORD_W]        r_idex_src2_imm     { pipeline = pipe.IDEX; };    // immediate valuie for src2

register bit[ALUOP_W]   r_idex_aluop            { pipeline = pipe.IDEX; };    // ALU opcode
register bit[BOOLEAN_BIT]  r_idex_regwrite      { pipeline = pipe.IDEX; };    // Does the current instruction wrt to RF
register bit[ALU_SRC1_SEL_W] r_idex_src1_sl     { pipeline = pipe.IDEX; };    // ALU src1 select lines for mux
register bit[ALU_SRC2_SEL_W] r_idex_src2_sl     { pipeline = pipe.IDEX; };    // ALU src2 select lines for mux
register bit[BOOLEAN_BIT]  r_idex_branch_inst   { pipeline = pipe.IDEX; };    // If true, conditional branch instruction
register bit[BOOLEAN_BIT]  r_idex_jump_inst     { pipeline = pipe.IDEX; };    // If true, jump instruction
register bit[MEM_OPCODE_W] r_idex_mem_ops       { pipeline = pipe.IDEX; };    // Opcode for Loads and Store operations (NOP = no load or store)
register bit[BOOLEAN_BIT]  r_idex_memread       { pipeline = pipe.IDEX; };    // If true, it is a Load operation
register bit[JUMP_DF_MUX_W] r_idex_jump_df_mux  { pipeline = pipe.IDEX; };    // jump address calculation source


register bit[BOOLEAN_BIT]  r_idex_src2_ex_hz       { pipeline = pipe.IDEX; };  // Passing src2 EX stage hazard detect to EX stage for Store rs2 forwarding
register bit[BOOLEAN_BIT]  r_idex_src2_mem_hz      { pipeline = pipe.IDEX; };  // Passing src2 MEM stage hazard detect to EX stage for Store rs2 forwarding



register bit[BOOLEAN_BIT]  r_idex_halt          { pipeline = pipe.IDEX; };    // Halt control bit


// -------------------------------------------------------------------------------------------------
// Execute stage
// -------------------------------------------------------------------------------------------------

// ALU signals
signal bit[WORD_W]  s_ex_soperand1;                                           // src1 operand into ALU
signal bit[WORD_W]  s_ex_soperand2;                                           // src2 operand into ALU
signal bit[WORD_W]  s_ex_alu_result;                                          // result of ALU operation
signal bit[BOOLEAN_BIT] s_ex_branch_true;                                     // true if branch condition is true

// EX signals
signal bit[ADDR_W] s_ex_target_address;                                       // calculate target address for branch operation

// memory operation signals
signal bit[WORD_W]      s_ex_mem_encodeddata;                                 // Encoded data for memory access
signal bit[2]           s_ex_mem_size;                                        // Memory bus access size
signal bit[WORD_W]      s_me_mem_result;                                      // read result from load
signal bit[BOOLEAN_BIT] s_me_mem_busy;                                        // Memory bus is busy


// EXMEM pipeline register
register bit[WORD_W]   r_exmem_alu_result           { pipeline = pipe.EXMEM; };    // Data result from ALU
register bit[RF_XPR_W] r_exmem_rd                   { pipeline = pipe.EXMEM; };    // rd / write register
register bit[BOOLEAN_BIT] r_exmem_regwrite          { pipeline = pipe.EXMEM; };    // Does the current instruction wrt to RF
register bit[BOOLEAN_BIT]  r_exmem_branch_inst      { pipeline = pipe.EXMEM; };    // If true, conditional branch instruction
register bit[BOOLEAN_BIT]  r_exmem_jump_inst        { pipeline = pipe.EXMEM; };    // If true, jump instruction
register bit[MEM_OPCODE_W] r_exmem_mem_ops          { pipeline = pipe.EXMEM; };    // Opcode for Loads and Store operations (NOP = no load or store)
register bit[BOOLEAN_BIT]  r_exmem_memread          { pipeline = pipe.EXMEM; };    // If true, it is a Load operation
register bit[BOOLEAN_BIT]  r_exmem_branch_true      { pipeline = pipe.EXMEM; };    // true if branch is to be taken
register bit[ADDR_W] r_exmem_target_address         { pipeline = pipe.EXMEM; };    // Address to branch or jump to if requiredopcode
register bit[WORD_W]   r_exmem_mem_encodeddata      { pipeline = pipe.EXMEM; };    // encoded memory access data
register bit[2]        r_exmem_mem_size             { pipeline = pipe.EXMEM; };    // Memory bus access size


// -------------------------------------------------------------------------------------------------
// Memory stage
// -------------------------------------------------------------------------------------------------
signal bit[BOOLEAN_BIT] s_me_take_branch;                                        //Informs the pipeline in a branch or jump is occuring


// MEMWB pipeline register
 register bit[WORD_W] r_memwb_result                {pipeline = pipe.MEMWB;};    // Data result from Memory stage
 register bit[RF_XPR_W] r_memwb_rd                  {pipeline = pipe.MEMWB;};    // rd / write register
 register bit[BOOLEAN_BIT] r_memwb_regwrite         {pipeline = pipe.MEMWB;};    // Does the current instruction wrt to RF


// -------------------------------------------------------------------------------------------------
// Writeback stage
// -------------------------------------------------------------------------------------------------




// -------------------------------------------------------------------------------------------------
// Pipeline control
// -------------------------------------------------------------------------------------------------

signal   bit[BOOLEAN_BIT] s_id_stall;
signal   bit[BOOLEAN_BIT] s_wb_stall;

// -------------------------------------------------------------------------------------------------
// SYSCALL support for simulation
// -------------------------------------------------------------------------------------------------
signal bit [BOOLEAN_BIT]   s_syscall_pending;
signal bit [BOOLEAN_BIT]   s_syscall_stall;
register bit [TWO_BIT]  r_syscall_delay             {default = 0;};

